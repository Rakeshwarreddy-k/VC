"use strict";(self.webpackChunkvirtualclient=self.webpackChunkvirtualclient||[]).push([[3531],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,h=d["".concat(l,".").concat(u)]||d[u]||c[u]||r;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8126:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={},i="Developer Guide",s={unversionedId:"developing/0010-develop-guide",id:"developing/0010-develop-guide",title:"Developer Guide",description:"Welcome to the Virtual Client development team! The Virtual Client is a .NET 6.0 command line application written in C# that offers both cross-platform and multi-architecture support. As such, the",source:"@site/docs/developing/0010-develop-guide.md",sourceDirName:"developing",slug:"/developing/0010-develop-guide",permalink:"/VirtualClient/docs/developing/0010-develop-guide",draft:!1,editUrl:"https://github.com/microsoft/VirtualClient/edit/main/website/docs/developing/0010-develop-guide.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Automated Build and CI/CD pipeline",permalink:"/VirtualClient/docs/developing/0001-ci-cd"},next:{title:"Developing Extensions",permalink:"/VirtualClient/docs/developing/0020-develop-extensions"}},l={},p=[{value:"Preliminaries",id:"preliminaries",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Practices and Principles",id:"practices-and-principles",level:2},{value:"Considerations When Getting Started",id:"considerations-when-getting-started",level:2},{value:"Platform/Core Projects and Libraries",id:"platformcore-projects-and-libraries",level:2},{value:"VirtualClientComponent",id:"virtualclientcomponent",level:2},{value:"Common/Shared Dependencies",id:"commonshared-dependencies",level:2},{value:"Coding Practices",id:"coding-practices",level:2},{value:"General Code Flow",id:"general-code-flow",level:2},{value:"The Component Base Class",id:"the-component-base-class",level:4},{value:"Component Code/Method Flow",id:"component-codemethod-flow",level:4},{value:"Trace Logging and Telemetry",id:"trace-logging-and-telemetry",level:2},{value:"Telemetry Loggers",id:"telemetry-loggers",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Debugging Virtual Client Code",id:"debugging-virtual-client-code",level:2},{value:"Debug in Visual Studio Using Unit/Functional Tests",id:"debug-in-visual-studio-using-unitfunctional-tests",level:4},{value:"Debug in Visual Studio by Running a Custom Profile",id:"debug-in-visual-studio-by-running-a-custom-profile",level:4}],m={toc:p};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"developer-guide"},"Developer Guide"),(0,o.kt)("p",null,"Welcome to the Virtual Client development team! The Virtual Client is a .NET 6.0 command line application written in C# that offers both cross-platform and multi-architecture support. As such, the\napplication can run on both Windows and Linux operating systems as well as on hardware with x64 and arm64 architecture CPUs/processors. The following documentation covers details, concepts and\npractices to consider when doing development work in the Virtual Client source code. The goal is to enable a developer new to the codebase to quickly understand the high level requirements and expectations before\nhe/she commits to doing work extending the features of the Virtual Client platform."),(0,o.kt)("h2",{id:"preliminaries"},"Preliminaries"),(0,o.kt)("p",null,"Before beginning, it is helpful to understand some of the concepts and foundations involved in Virtual Client development. The following links provide\nplatform overview and design concepts. The remainder of this guide will use terms that are covered in these documents, so it is important to go through\nthese first."),(0,o.kt)("p",null,"If you are developing extensions to the Virtual Client platform in another repo, the following documentation can get you started."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/VirtualClient/docs/developing/0020-develop-extensions"},"Developing Virtual Client Extensions"))),(0,o.kt)("p",null,"After going through this developer guide, there are links code examples at the bottom of this document to get you hands-on experience."),(0,o.kt)("h2",{id:"terminology"},"Terminology"),(0,o.kt)("p",null,"For the sections that follow, the term '",(0,o.kt)("strong",{parentName:"p"},"component"),"' is used to describe a Virtual Client action, monitor or dependency. These will be concrete class implementations\nreferenced in Virtual Client profiles. In the example below, the 'OpenSslExecutor', 'DependencyPackageInstallation' and 'PerfCounterMonitor' are ALL components. All components\nin the Virtual Client derive from the base class 'VirtualClientComponent'."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'# In the example below, the OpenSslExecutor, DependencyPackageInstallation and PerfCounterMonitor are all\n# generically called \'components\'.\n{\n    "Description": "OpenSSL 3.0 CPU Performance Workload",\n    "Parameters": { },\n    "Actions": [\n        {\n            "Type": "OpenSslExecutor",\n            "Parameters": {\n                "Scenario": "MD5",\n                "CommandArguments": "speed -elapsed -seconds 100 md5",\n                "PackageName": "openssl",\n                "Tags": "CPU,OpenSSL,Cryptography"\n            }\n        }\n    ],\n    "Dependencies": [\n        {\n            "Type": "DependencyPackageInstallation",\n            "Parameters": {\n                "Scenario": "InstallOpenSSLWorkloadPackage",\n                "BlobContainer": "packages",\n                "BlobName": "openssl.3.0.0.zip",\n                "PackageName": "openssl",\n                "Extract": true\n            }\n        }\n    ]\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"// They all derive from the base class VirtualClientComponent\n\n/// <summary>\n/// The OpenSSL workload executor component.\n/// </summary>\npublic class OpenSslExecutor : VirtualClientComponent\n\n/// <summary>\n/// The Azure blob package dependency installation component.\n/// </summary>\npublic class DependencyPackageInstallation : VirtualClientComponent\n")),(0,o.kt)("h2",{id:"practices-and-principles"},"Practices and Principles"),(0,o.kt)("p",null,'Before digging into the finer-grained details of development work in the Virtual Client codebase, it is important to understand the high-level practices\nand principles the VC Team follows. The practices and principles the team follows are intended to promote rapid software feature development while ensuring\nhigh quality designs and a codebase that can be sustainably maintained over time. These practices are well-vetted learned over many years in the "school of hard\nlessons learned". As such, it is important for developers new to the Virtual Client codebase to follow the practices when possible. That said the most\nimportant thing is to keep things as simple as possible.'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Keep it Simple"),(0,o.kt)("br",{parentName:"p"}),"\n",'Whereas it is difficult to keep everything simple all the time when implementing new logic, it is important to try. It helps to focus on the exact\nrequirements when implementing a solution and to avoid allowing the scope to creep to things that are not actually needed. It is easy to have thoughts\nsuch as "what if we need this in the future", but this can easily lead to over-engineered solutions with difficult to maintain/extend code. The process\nof unit testing (as noted below) is very helpful as a guide for writing just the right amount of code.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Enforce isolation with new actions/executors, monitors and dependencies"),(0,o.kt)("br",{parentName:"p"}),"\n","When developing new actions/executors, monitors or dependencies in Virtual Client, it is important to try to isolate the logic\nof that component from other components. Common/shared dependencies used by all Virtual Client components are carefully implemented\nin the 'Core' project; however, other components should be cautious to use shared logic that is NOT a part of the Core. This helps\nto prevent a problem with one component from accidentally impacting another. This is an especially important concept given how many\ndistinct workload executors, monitors and dependencies exist in Virtual Client with the list constantly growing.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Functionality that is shared by all components should be part of the 'Core' project"),(0,o.kt)("br",{parentName:"p"}),"\n","There are dependencies that are required by most components in the Virtual Client. The implmentations of these hold a high quality bar\nbecause they are so fundamental to the operations of the Virtual Client application as a whole. Most of the necessary dependencies have been\nimplemented. However if a new dependency is required in Virtual Client that is to be shared across all providers, it should be implemented\nin the 'Core' project. Note that something is not \"common\" because it might be in the future. A component is common when it is used by many\nother components across the codebase. For example, the package manager is used by almost every Virtual Client component. As a general rule,\na new component should not be added to the 'Core' project until it is definitively used by more than 2 or 3 distinct other components. "),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Core"},"VirtualClient.Core Project")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Unit tests are fundamental to development quality-at-speed."),(0,o.kt)("br",{parentName:"p"}),"\n",'One of the fundamental goals of the VC Team is to enable high quality development at-speed. To accomplish this as the size\nand complexity of the codebase grows, it is very important to have good unit tests in place for each component or supporting\nclass. The process of writing unit tests acts as a concrete guide in the development process forcing the developer to think\ndeeply about the code he/she is writing. This is NOT meant to slow the developer down but instead helps to ensure high quality\ndesign with minimal code...it is a particularly good process for this goal. A favorite motto of the team is: "you have to go slow to\ngo fast". This means that the developer will invest more time up front in the development process to ensure faster development down\nthe road. This happens because the code is often well-thought out without being over-engineered and there are programmatic tests\nin place protecting the correct functioning of the logic for the future. There are plenty of good examples and patterns in the source\ncode to follow.'),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/VirtualClient/docs/developing/0090-testing"},"Testing Guide")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Functional tests are required for new profiles."),(0,o.kt)("br",{parentName:"p"}),"\n",'Functional tests are similar to unit tests except that they focus on the correct integration of all components. When the VC Team creates new\nworkload or monitoring profiles, functional tests are also created. Whereas unit tests focus on classes meeting all important "specifications",\nfunctional tests focus on the interactions between components being correct. There are plenty of good examples and patterns in source code\nto follow.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"New profiles (or components within them) must be documented"),(0,o.kt)("br",{parentName:"p"}),"\n","Each time the VC Team onboards a new workload, monitor or dependency it is documented in the repo within the 'VirtualClient.Documentation'\nfolder. Good documentation is an important part of the quality bar that the team holds ensuring that users/customers can always learn more\nabout the Virtual Client. There are patterns in place within the documentation to guide developers through the process.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Components should be implemented to support ALL possible platform/architectures"),(0,o.kt)("br",{parentName:"p"}),"\n","The Virtual Client is generally designed to run in as many scenarios as possible. To do so, a developer has to consider whether the component\nthey are onboarding can run on Windows or Linux, x64 (Intel, AMD) or ARM64 architecture. Many times the .NET framework itself provides for the\nability to run cross-OS platform/cross-CPU architecture. However, there are times when the logic must implement support in a slightly different\nway. It is always a goal to implement new features and components such that they cover ALL possible scenarios. By doing so, the value of the\nVirtual Client to users/partners/customers is increased because it can cover more of the scenarios that are important to them.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Components should be written to be idempotent"),(0,o.kt)("br",{parentName:"p"}),"\n",'The term "Idempotent" in this context refers to the ability of a component to be ran any number of times back-to-back without changing the\ndesired outcome. For example, a component that is responsible for installing a particular dependency should not change the state of that dependency\nonce installed nor should it fail on a second, third etc... run. A component that is responsible for running a workload or test should be able\nto successfully run that workload or test on each and every subsequent run. In practice, this sometimes mean avoiding doing work that has already\nbeen performed (e.g. installing a given dependency) and cleaning up either at the beginning or end of the component execution.'),(0,o.kt)("p",{parentName:"li"},"The Virtual Client core platform has a state manager that allows components to preserve state information (in files on the local system) so that they\ncan be referenced later or on subsequent runs. This is useful for example to save off information that indicates some specific operation was performed\nthat could fail if attempted a second time in succession."))),(0,o.kt)("h2",{id:"considerations-when-getting-started"},"Considerations When Getting Started"),(0,o.kt)("p",null,"As a developer is starting to think about contributing to the Virtual Client codebase, there are a few things that are helpful to consider as a guide.\nThe following sections provide some high-level ideas to help form a plan. The sections below are written to account for the onboarding of an entirely\nnew component (workload, monitor) to the Virtual Client so as to cover the space thoroughly."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Familiarize yourself with the platform concepts"),(0,o.kt)("br",{parentName:"p"}),"\n","It is important to understand the fundamental concepts for the Virtual Client before beginning. If you did not go through the platform overview\nand design documentation at the top, please do so before continuing.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Identify your dependencies"),(0,o.kt)("br",{parentName:"p"}),"\n","One of the very first things to do when getting started with a new component implementation is to identify all of the dependencies that your\ncomponent will have. This will inform whether you need to package those as a Virtual Client package or install them in other ways. For example:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Workload scripts or binaries."),(0,o.kt)("li",{parentName:"ul"},"Dependencies/packages that have to be installed for workload scripts or binaries (e.g. apt, debian, chocolatey)."),(0,o.kt)("li",{parentName:"ul"},"Configurations/settings for the system/OS (e.g. registry keys, TCP ephemeral ports)."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Identify what type of component you are implementing: action, monitor or dependency"),(0,o.kt)("br",{parentName:"p"}),"\n",'The Virtual Client has 3 key types of components in source: actions, dependencies and monitors. Components that are "Fundamental" belong in the Virtual Client\nplatform/core repo. Components that are "Domain-Specific" belong in a separate repo. Developers will reference a few key libraries from the Virtual Client platform/core\nrepo (specifically Contracts and Core libraries published as NuGet packages) for integration.'),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Actions"),(0,o.kt)("br",{parentName:"p"}),"\n","Actions are used to implement components that execute workloads/tests or scripts. These represent the benchmarks, validation tests or customer-representative work that is\nhappening on the system. For example, the 'OpenSslExecutor' referenced at the top of this document is a component that executes a workload that tests the CPU on the system\ncalled 'OpenSSL SPeed'. It is an industry-standard cryptography benchmarking workload.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Dependencies"),(0,o.kt)("br",{parentName:"p"}),"\n","Dependencies are used to implement components that setup or install dependencies on the system required by actions and monitors in a profile. For example,\nthe 'DependencyPackageInstallation' component referenced at the top of this document is a component that downloads Virtual Client packages from an Azure storage account\nto the system at runtime. ")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Monitors"),(0,o.kt)("br",{parentName:"p"}),"\n","Monitors are used to implement components that run in the background and capture important information from the system under load. For example, the 'PerfCounterMonitor'\nreferenced at the top of this document is a component that captures performance counters from the system while workloads/tests are running.")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Learn how the workload/test, monitor or dependency works"),(0,o.kt)("br",{parentName:"p"}),"\n","When onboarding a new workload/test or monitor, time MUST be spent learning how it works. This will allow the developer to make and informed decision on how the\napplication should run as part of defining a Virtual Client profile in which it is integrated. This is very, very important to the goals of the Virtual Client. The user of the\nplatform should NOT have to know very much about the  or be an expert in it in order to take advantage of the expertise built into Virtual Client on their behalf. In fact, this principle\nis fundamental to the idea of the Virtual Client and the primary reason why profiles exist. A profile represents the expertise of the developers that integrated\ncomponents into the Virtual Client. This includes the expertise of other teams of subject matter experts consulted during the discovery work. At the end of the day,\na user of the Virtual Client should be able to take advantage of the expertise of many when running a workload and should have trust in the information that is\nproduced. This depends on you, the developer doing the hard due diligence work to truly understand what the workload does and how to run it effectively."),(0,o.kt)("p",{parentName:"li"},"Team members typically use virtual machines in a subscription for exploratory work to learn how a particular application being onboarded works. Contact the team\nusing information in the general documentation at the top of this document if you need virtual machine support.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Create Virtual Client packages (.vcpkg) for certain dependencies"),(0,o.kt)("br",{parentName:"p"}),"\n","Many dependencies for the Virtual Client such as a workload or monitor will be packaged in a Virtual Client (.vcpkg) package. Developers do not necessarily\nneed to create custom VC packages for everything. However, it is common practice to create packages for the Virtual Client containing required dependencies\n(e.g. workloads, Java runtime, PowerShell, Python) so that they can be put in a package/blob store for download at runtime. Virtual Client profiles are designed\nto download and install required dependencies. This is not required, but it is convenient and helps to make Virtual Client easy to deploy into a wide range of\nenvironments/scenarios."),(0,o.kt)("p",{parentName:"li"},"Another benefit of placing dependencies in custom Virtual Client packages is that it enables Virtual Client to support \"disconnected\" scenarios. These\nare scenarios where the Virtual Client will need to run on a system that does not have a network connection. For example, a set of workloads might require\nthe Python3 framework to run despite the disconnected scenario. It cannot be downloaded at runtime. In this example, the workloads would be placed in a package\nand the Python3 framework libraries in a separate package (for reusability with other workloads in the future). These packages would be deployed with the Virtual\nClient in the 'packages' folder so that there is no need for Virtual Client to download them."))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Design your workload or monitor profile"),(0,o.kt)("br",{parentName:"p"}),"\n","Virtual Client profiles represent the interface to the user for your workloads/tests, monitors and dependencies. They represent the expertise that a developer gained\nthroughout the discovery process for a new component being onboarded to the Virtual Client. It is common for example for a new workload/test to have a single profile\nthat a user can reference on the command line to run that workload/test in one or more ways that represent a holistic scenario. A profile should define a scenario that\nis both whole (in terms of breadth of coverage on a system) as well as trustworthy (in terms of quality of coverage on the system). As noted above, the user should not\nneed to be an expert in the workload/test or monitor in order to take advantage of the expertise within."),(0,o.kt)("p",{parentName:"li"},"As was covered in the platform design documentation at the top, Virtual client profiles are divided into 2 types of profiles: workload/test profiles and monitoring profiles.\nThis allows the user to run different workloads/tests on a system with different monitors as they require. "),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"},"VirtualClient.exe --profile=PERF-CPU-OPENSSL.json --profile=MONITORS-DEFAULT.json --timeout=1440 --system=Demo\n")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Main/profiles"},"Existing Profiles"))))),(0,o.kt)("h2",{id:"platformcore-projects-and-libraries"},"Platform/Core Projects and Libraries"),(0,o.kt)("p",null,"Before beginning the discussion of development/programming aspects of the Virtual Client, the following section covers the important projects that\nexist within the Virtual Client platform/core codebase. It is helpful to understand what components are implemented in each of these projects."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"VirtualClient.Contracts"),(0,o.kt)("br",{parentName:"p"}),"\n","This project contains all of the fundamental data contract/model and POCO (plain old C# object) classes that are used by Virtual Client components. This\nproject additionally contains the logging extensions that are used to create the structured/schematized telemetry foundation that ensures data\nemitted by the Virtual Client follows consistent patterns and is easily/readily consumable for data analysis.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"VirtualClient.Core"),(0,o.kt)("br",{parentName:"p"}),"\n",'This project contains all of the important shared/core dependency interfaces and implementations  used by all Virtual Client components\n(e.g. workload executors, monitors and dependency installers/handlers). This is the "common" class library if you will.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"VirtualClient.Actions"),(0,o.kt)("br",{parentName:"p"}),"\n","This project contains \"Fundamental\" workload/test executor implementations. The components within this project can be seen referenced in the\n'Actions' section of related workload profiles."),(0,o.kt)("p",{parentName:"li"},"This project also contains classes/implementations of various results/raw text parsers that are used in conjuction with workload/test executors\nto read important information/data (e.g. metrics) from the output of workloads. The parsing of results is complex enough to\nkeep the implementation separate from the workload executors and to ensure reusability for different implementations of a related\nworkload executor.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"VirtualClient.Api"),(0,o.kt)("br",{parentName:"p"}),"\n","This project contains the Virtual Client API. This is a self-hosted REST API that allows instances of the Virtual Client running on\ndifferent systems to communicate with each other. This is important for workloads that require multi-system/tier topologies to conduct\nthe workload operations (e.g. client/server interactions).")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"VirtualClient.Dependencies"),(0,o.kt)("br",{parentName:"p"}),"\n","This project contains \"Fundamental\" dependency installer/handler classes/implementations. The components within this project can be seen referenced in the\n'Dependencies' section of related workload or monitoring profiles.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"VirtualClient.Monitors"),(0,o.kt)("br",{parentName:"p"}),"\n","This project contains \"Fundamental\" background monitor implementations. The components within this project can be seen referenced in the\n'Monitors' section of related monitoring profiles."),(0,o.kt)("p",{parentName:"li"},"This project also contains classes/implementations of various results/raw text parsers that are used in conjuction with monitors\nto read important information/data (e.g. metrics) from the output of monitors. The parsing of results is complex enough to\nkeep the implementation separate from the monitors and to ensure reusability for different implementations of a related\nmonitor.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"VirtualClient.Packaging"),(0,o.kt)("br",{parentName:"p"}),"\n","This project contains workload binaries, scripts etc... required to build certain workload and dependency packages for use with the\nVirtual Client.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"VirtualClient.TestExtensions"),(0,o.kt)("br",{parentName:"p"}),"\n","This project contains classes/implementations that are used to test Virtual Client codebase components. Mock fixtures for example are used\nextensively to reduce duplication and to simplify the setup of different mocks and behaviors in Virtual Client unit and functional tests.\nThe test assets in the Virtual Client codebase are as equally important as the code for which they are testing. The Virtual Client codebase\nutilizes the classes/implementations in this project to enable faster velocity in writing new tests and to ensure consistent patterns\nof testing throughout."))),(0,o.kt)("h2",{id:"virtualclientcomponent"},"VirtualClientComponent"),(0,o.kt)("p",null,"The 'VirtualClientComponent' class is the fundamental base class for all components (e.g. workload/test executors, monitors and dependency installers/handlers) within\nthe codebase. This class allows certain very common requirements to be consolidated in a single place."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Common/Shared Dependencies"),(0,o.kt)("br",{parentName:"p"}),"\n","Common dependencies (e.g. package manager, disk manager, file system manager) are passed into the constructors of all components via\nan IServiceCollection instance. This is the principle of dependency injection which creates flexibility for both runtime as well as test\ntime executions of code paths. These coded dependencies are created at the start of the Virtual Client and are available to every component\nthat runs regardless of when it runs so it is very easy to access the shared platform runtime interfaces.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Component Parameters"),(0,o.kt)("br",{parentName:"p"}),"\n","All parameters that are either defined on the component itself in a workload or monitoring profile or that were passed in on the command line are passed\ninto the constructor of the component. This allows the component to operate based on parameters defined in the profile or for those that were overridden by\nthe user on the command line."))),(0,o.kt)("h2",{id:"commonshared-dependencies"},"Common/Shared Dependencies"),(0,o.kt)("p",null,"All workload executors, monitors and dependency installers/handlers share a common set of requirements. These requirements are encapsulated into a set of core interfaces\nand implementations in the Virtual Client. The following section describes each of the most important categories of shared dependencies as well as their\nimplementations. As described above, these commons/shared dependencies are passed into the constructor of all workload executor, monitors and dependency\nhandlers for use. The interfaces and implementations below exist in the 'VirtualClient.Core' project as noted above."),(0,o.kt)("p",null,'Note that the use of interfaces is part of a "program to interfaces" design principle. Whereas the incorporation of interfaces in a codebase increases the\nlearning curve for developers trying to understand the flow, it is important to keep abstractions to a minimum. As a general rule, the VC Team tries to have a single\ninterface and implementation for a given dependency. This allows flexibility for different "live" scenarios as well as for deep/robust ability to test the code\nfor functional correctness.'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"API Clients"),(0,o.kt)("br",{parentName:"p"}),"\n","Certain workload scenarios require multiple systems to operate (e.g. networking workloads, client/server). These workloads have a requirement to communicate\nwith each other to be able to synchronize client-side executions with server-side expectations. The Virtual Client uses an ",(0,o.kt)("a",{parentName:"p",href:"/VirtualClient/docs/guides/0020-client-server"},"environment layout")," provided on\nthe command line to determine the IP addresses of other instances. API client creation and management is encapsulated in the following interfaces/classes:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"IApiClientManager"),(0,o.kt)("li",{parentName:"ul"},"ApiClientManager"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Blob Store Upload/Download Requirements"),(0,o.kt)("br",{parentName:"p"}),"\n","The Virtual Client supports the ability to upload and download files/content from an Azure storage account blob store (and other cloud blob stores in the future). Blob store interactions\nare encapsulated in the following interfaces/classes:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"IBlobManager"),(0,o.kt)("li",{parentName:"ul"},"BlobManager"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Disk Management"),(0,o.kt)("br",{parentName:"p"}),"\n","Certain workloads available in the Virtual Client require the ability to read information from the system about disks attached as well as to initialize/format\nthe disks. For example, the FIO workload is designed to test the disks on the system for I/O performance. With Azure virtual machines, managed/remoted disks are\ntypically attached in a raw state uninitialized and unformatted. They must be prepped with a file system before any I/O tests can be ran using them. Disk management\nfeatures are encapsulated in the following interfaces/classes:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"IDiskManager"),(0,o.kt)("li",{parentName:"ul"},"DiskManager"),(0,o.kt)("li",{parentName:"ul"},"UnixDiskManager"),(0,o.kt)("li",{parentName:"ul"},"WindowsDiskManager"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Firewall Management"),(0,o.kt)("br",{parentName:"p"}),"\n","Some workloads require changes to the firewall on the system in order to operate. This might include opening ports (e.g. TCP, UDP) or enabling certain applications\nto execute freely. Firewall management features are encapsulated in the following interfaces/classes:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"IFirewallManager"),(0,o.kt)("li",{parentName:"ul"},"FirewallManager"),(0,o.kt)("li",{parentName:"ul"},"UnixFirewallManager"),(0,o.kt)("li",{parentName:"ul"},"WindowsFirewallManager"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Package Management"),(0,o.kt)("br",{parentName:"p"}),"\n","With the sheer number of different workloads available in the Virtual Client, there are a lot of different workload and dependency packages that are required. The application\ndelegates the responsibility for downloading, extracting and keeping track of all of the various packages using a package manager. The package management foundation\nsupports the ability to download packages from both NuGet feeds as well as from Azure storage account blob stores. Package management features are encapsulated in the\nfollowing interfaces/classes."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"IPackageManager"),(0,o.kt)("li",{parentName:"ul"},"PackageManager"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Process Management"),(0,o.kt)("br",{parentName:"p"}),"\n","The Virtual Client runtime platform execute operating system processes often as part of just about every workload/test executor, monitor or dependency installer/handler. In addition\nthere are times when processes need to be launched with elevated privileges. The responsibility for creating and managing processes within the runtime is encapsulated in the\nfollowing interfaces/classes."))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"ProcessManager")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"UnixProcessManager")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"WindowsProcessManager")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"IProcessProxy")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"ProcessProxy")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"State Management"),(0,o.kt)("br",{parentName:"p"}),"\n","Certain scenarios require the ability to preserve state information in between operations. For example, there are operations that make configuration settings changes to the\nsystem and then require a reboot. When the Virtual Client is restarted, it needs to know what previous requirements were completed. State management is also very important\nfor workloads that require multiple systems (client/server) to enable information to be passed back and forth between one instance and another of the Virtual Client. State management\nfeatures are encapsulated in the following interfaces/classes:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"IStateManager"),(0,o.kt)("li",{parentName:"ul"},"StateManager"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"System Management"),(0,o.kt)("br",{parentName:"p"}),"\n","Because of there are quite a few different dependency interfaces/classes that are required to support the needs of executing a wide range of workloads on the system, all common\ndependencies noted above are consolidated together into a single abstraction to simplify the discovery of what is available. Additionally, there are a few requirements that\nare extensions to behaviors that use the dependencies above that are a part of the system management abstraction. The following interfaces/abstractions provide for the\ncommon system management features:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"ISystemInfo"),(0,o.kt)("li",{parentName:"ul"},"ISystemManagement"),(0,o.kt)("li",{parentName:"ul"},"SystemManagement"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Telemetry Management"),(0,o.kt)("br",{parentName:"p"}),"\n","Telemetry is a critical part of the Virtual Client runtime platform operation. Lots and lots of telemetry is emitted and is used for every data-related requirement on the system.\nThe class implementations used in the Virtual Client ALL follow the .NET team's logging patterns using the 'ILogger' recommendations."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line"},".NET ILogger interface/pattern"),". ")))),(0,o.kt)("p",null,"  The fundamental classes/interfaces used to emit telemetry in the Virtual Client are as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"VirtualClientLoggingExtensions")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"VirtualClientTelemetryExtensions")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"EventContext")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"ConsoleLogger")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"AppInsightsTelemetryLogger")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"EventHubTelemetryLogger")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"SerilogFileLogger"))),(0,o.kt)("h2",{id:"coding-practices"},"Coding Practices"),(0,o.kt)("p",null,'The following section describes some of the high-level practices and recommendations to follow when working in the Virtual Client codebase. This is not an\nexhaustive list but does illustrate things that are "fundamental" to development in the codebase.'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Use the async/await pattern"),(0,o.kt)("br",{parentName:"p"}),"\n",'The C# programming language (as of version 6.0) has great support for asynchronous programming. Asynchronous programming allows for the application to be\nfar more efficient in the usage of system primitive resources for I/O-bound or CPU-bound operations. The Virtual Client runtime platform itself MUST run as\nefficiently as possible. This is especially the case when it is running a resource-sensitive benchmark, workload or test. This is because the resources that the\nVirtual Client itself uses in order to operate as a runtime platform on the system affect the resources available t othe workload and can cause "noise" in the\ndata that is emitted. For example, were the Virtual Client itself to use too many CPU/process resources/cycles when running a workload that is designed to\nbenchmark the performance of the CPU/processor, the performance results of the benchmark could be skewed to be less accurate.'),(0,o.kt)("p",{parentName:"li"},"This pattern is used pervasively throughout the Virtual Client codebase so there are plenty of examples. You can familiarize yourself with asynchronous\nprogramming concepts and techniques in Microsoft public documentation."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/dotnet/csharp/async"},"Asynchronous Programming in C#")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Date/Time values should ALWAYS be in universal time (UTC)"),(0,o.kt)("br",{parentName:"p"}),"\n","When referencing any date/time objects, always represent them in UTC (e.g. DateTime.UtcNow). This is especially important when emitting data. The Virtual Client\nruns all over the planet. It is much easier to convert a date in UTC form to any other timezone form. It is much harder to do this the other way around when you do\nnot know what timezone a date reference was in originally. Suffice to say, just use UTC times everywhere always!")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Write unit tests at the same time as writing your components"),(0,o.kt)("br",{parentName:"p"}),"\n",'Unit tests programmatically validate the functional correctness of the important behaviors of a given class. Unit testing as a process is extremely important to\nthe development practices in the Virtual Client. The process of writing unit tests at the same time as writing new components allows the developer a concrete way to check\nthe quality of the design as well as the code for a new component. In fact, there is no faster way to test new code than a set of unit tests. This is increasingly so over time\nas new coded features are added to existing classes. VC Team members follow a hybrid "behavior-driven development" process where unit tests are written incrementally\nat the same time as writing the new component code itself. These tests are named as if they are a "specifications" document. Indeed the names of the test methods in the\ncodebase might surprise folks at times being rather long and descriptive at times. This is very purposeful. Unit tests ARE a specification of a class that is being\ndeveloped and should thus read like a list of specs. Correspondingly specifications MUST cover every single discreet/singular behavior that is critical to the correct\nfunctioning of a given class.'),(0,o.kt)("p",{parentName:"li"},"Over time as the codebase grows, unit tests act as protection for the quality of the application as a whole. Indeed 80% or better of functional regressions and bugs can be\nminimized or eliminated simply by having good unit tests in place. This in turn allows developers to rapidly prototype and implement new features in the Virtual Client\nplatform (i.e. high quality development at-speed).")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Use the platform test/mock fixtures to help you write unit tests"),(0,o.kt)("br",{parentName:"p"}),"\n","The Virtual Client platform/core repo has a set of mock fixtures and extensions in the 'VirtualClient.TestExtensions' folder that make it easier to do setup and validations in unit\ntests. The patterns are pervasive throughout the unit test projects within the platform/core repo. These mock fixtures greatly simplify the process of writing unit tests\nat the same time as they help to keep your unit test class code cleaner, simpler and more readable.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Use the core dependencies interface 'ISystemManagement' to integrate with the runtime platform as well as the operating system on which you are running"),(0,o.kt)("br",{parentName:"p"}),"\n","Every workload/test executor, monitor or dependency needs to access something from the runtime platform or on the operating system. For example, the developer may\nneed to access the file system, get information about disks on the system, create processes to run a workload or find the location of packages on the system. Core\ncode dependencies are implemented behind a set of common interfaces as noted above. The 'ISystemManagement' interface contains/exposes ALL of them in a single place\n(e.g. ISystemManagement.DiskManager, ISystemManagement.PackageManager). Because ALL shared dependencies are accessed using these interfaces, the entire codebase can\nbe thoroughly tested. This is key to keeping the design and functional quality bars high in Virtual Client. The following interfaces are available on the ISystemManagement\ninterface and can be used:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Use the 'IApiClientManager' instance for API client creation and operations.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"(i.e. ISystemManagement.ApiClientManager)",(0,o.kt)("br",null),(0,o.kt)("br",null)))),(0,o.kt)("li",{parentName:"ul"},"Use the 'IFileSystem' instance for file system operations.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"(i.e. ISystemManagement.FileSystem)",(0,o.kt)("br",null),(0,o.kt)("br",null)))),(0,o.kt)("li",{parentName:"ul"},"Use the 'IDiskManager' instance for disk operations.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"(i.e. ISystemManagement.DiskManager)",(0,o.kt)("br",null),(0,o.kt)("br",null)))),(0,o.kt)("li",{parentName:"ul"},"Use the 'IFirewallManager' instance for firewall operations.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"(i.e. ISystemManagement.FirewallManager)",(0,o.kt)("br",null),(0,o.kt)("br",null)))),(0,o.kt)("li",{parentName:"ul"},"Use the 'IPackageManager' instance for package download, extraction and locating operations.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"(i.e. ISystemManagement.PackageManager)",(0,o.kt)("br",null),(0,o.kt)("br",null)))),(0,o.kt)("li",{parentName:"ul"},"Use the 'ProcessManager' instance for operating system process creation and execution operations.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"(i.e. ISystemManagement.ProcessManager)",(0,o.kt)("br",null),(0,o.kt)("br",null)))),(0,o.kt)("li",{parentName:"ul"},"Use the 'IStateManager' instance for local state preservation operations.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"(i.e. ISystemManagement.StateManager)",(0,o.kt)("br",null),(0,o.kt)("br",null)))),(0,o.kt)("li",{parentName:"ul"},"use the 'PlatformSpecifics' instance for folder/file path creation/combining operations.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"(i.e. ISystemManagement.PlatformSpecifics)")))),(0,o.kt)("br",null))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class OpenSslExecutor : VirtualClientComponent\n{\n    public OpenSslExecutor(IServiceCollection dependencies, IDictionary<string, IConvertible> parameters)\n    {\n         // ISystemManagement has all shared/core dependencies.\n         ISystemManagement systemManagement = dependencies.GetService<ISystemManagement>();\n         IFileSystem fileSystem = systemManagement.FileSystem;\n         IPackageManager packageManager = systemManagement.PackageManager;\n\n         // Or...every interfaced instance on ISystemManagement is also available in the dependencies\n         // supplied to every Virtual Client component constructor.\n         IFileSystem fileSystem = dependencies.GetService<IFileSystem>();\n         IPackageManager packageManager = dependencies.GetService<IPackageManager>();\n    }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Keep your components isolated from other components as much as possible"),(0,o.kt)("br",{parentName:"p"}),"\n","Each workload/test executor, monitor or dependency installers/handler should focus on one thing and do that well. By that definition, it is natural to assert that the logic within\nthat component should be isolated from other components. Over time the number of workload executors, monitors and dependency installers/handlers grows and it becomes harder\nand harder to protect the runtime platform application from regressions and bugs. One way to help accomplish this this is to be methodical about how code for one component\ncan affect another component. If the 2 components do not share any code, then it is much less likely that a regression or bug in 1 of them causes the same in the other. The\nshared/core dependencies exist to make this possible given the reality that very little code in an application can be 100% isolated. However, we purposefully minimize the shared\ncode between components. We instead harden the shared/core dependencies and enforce their use within workload/test executors, monitors and dependencies. The following are a\nfew examples of how you keep your components isolated."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Avoid shared base classes in your components beyond the base 'VirtualClientComponent' class.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},'Contrary to what you may have learned, do not try to make everything "common/shared" code just because a few components need the same thing. Common code paths represent\nplaces where a single bug can break many things. Hence the bar for defining what makes something "common" must be kept high. As a general rule, common/shared code should be reserved\nfor logic that is used by at least 20% of all components within the platform/core. Keep the logic isolated in your own components until that point or until otherwise instructed.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Keep constants and enums defined within your component. Same as above, they are NOT common until demonstrably proven to be using the same general rule.")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Keep your package names lower-cased"),(0,o.kt)("br",{parentName:"p"}),"\n","Windows paths, folder and file names are not case-sensitive. However on Unix/Linux they are. Packages are often downloaded to the system by the Virtual Client and then\nreferenced in code by path and by name. To make cross-platform coding easier, just keep the package names lower-cased because this will work on both operating system\nplatforms. This includes the name of the package file itself (e.g. diskspd.1.2.3.zip -> package name = diskspd).")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Keep the names of any folder or files created programmatically lower-cased"),(0,o.kt)("br",{parentName:"p"}),"\n","For the same reason as the bullet point above, it is best to keep any programmatically created folder or file names lower-cased.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Use the PlatformSpecifics.Combine() instead of Path.Combine() for referencing or combining paths"),(0,o.kt)("br",{parentName:"p"}),"\n","Do not use Path.Combine(). Use ISystemManagement.PlatformSpecifics.Combine() instead. Virtual Client operates on both Windows and Unix/Linux systems. The format of paths on these two operating system platforms differs.\nOn Windows backslashes are used (e.g. C:\\any\\path\\to\\something). On Unix/Linux forward slashes are used (e.g. /home/user/any/path/to/something).\nWhereas the .NET framework typically handles combining paths (e.g. Path.Combine), do not use this in the code. Related to the bullet point above\non unit tests, this allows tests to be written that can target either Windows or Unix/Linux that can be ran on a Windows system for example while\nmaintaining the semantics of the other platform. This is especially important for testing components that run on either Windows or Unix/Linux.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Always add useful context information to telemetry events/event context"),(0,o.kt)("br",{parentName:"p"}),"\n","The Virtual Client emits a lot of very good telemetry and this is very helpful especially for cases were debugging after it has ran is necessary. The best way to help\na user with debugging issues is to ensure proper context-specific information is included in the telemetry events emitted. All Virtual Client components emit telemetry\nand are passed an 'EventContext' object from the base VirtualClientComponent class. This object allows the developer to add additional context to the telemetry that will\nbe emitted. Imagine you will have to debug a problem. What information would be helpful? Include that type of information in the context."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'// For example:\n// It is usefult to capture context-specific information related to a process being executed \n// (the command, arguments, exit codes, standard output, standard error etc...)\nEventContext relatedContext = telemetryContext.Clone()\n    .AddContext("command", workload.Command)\n    .AddContext("commandArguments", workload.CommandArguments);\n\nreturn this.Logger.LogMessageAsync($"{nameof(FioExecutor)}.ExecuteProcess", relatedContext, async () =>\n{\n   try\n   {\n       using (IProcessProxy process = this.processManager.CreateProcess(pathToExe, commandLineArguments))\n       {\n          await process.StartAndWaitAsync(cancellationToken).ConfigureAwait(false);\n          if (!cancellationToken.IsCancellationRequested)\n          {\n              // Capture the process outcome details\n              this.Logger.LogWorkloadProcessDetails<OpenSslExecutor>(process, relatedContext);\n\n              process.ThrowIfErrored<WorkloadException>(ProcessProxy.DefaultSuccessCodes, errorReason: ErrorReason.WorkloadFailed);\n          }\n       }\n   }\n   catch (Exception exc)\n   {\n       // Always capture unexpected exception/error information\n       relatedContext.AddError(exc);\n       throw;\n   }\n});\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Throw useful exceptions"),(0,o.kt)("br",{parentName:"p"}),"\n","Whenever developing new components, there will be certain scenarios that can happen where exceptions are explicitly thrown. Exceptions represent cases where\na set of expectations required for the application to run correctly cannot be met. This is such an important aspect of programming in the Virtual Client that\nit has its own developer guidance documentation. Follow the recommendations in the documentation to ensure high quality exceptions and error information is\nalways provided to users of the Virtual Client."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/VirtualClient/docs/developing/0070-error-handling"},"Virtual Client Error Handling Developer Guide"))))),(0,o.kt)("h2",{id:"general-code-flow"},"General Code Flow"),(0,o.kt)("p",null,"The following section provides information on the general flow of the code for a Virtual Client component. This is helpful to understand when developing new\ncomponents for the platform."),(0,o.kt)("h4",{id:"the-component-base-class"},"The Component Base Class"),(0,o.kt)("p",null,"Firstly, all components in the Virtual Client whether action, monitor or dependency handler derive/inherit from the base class ",(0,o.kt)("strong",{parentName:"p"},"VirtualClientComponent"),". Thus, when\nimplementing any new components, the developer should inherit from this class. The base class has a single constructor that must be implemented in the\nnew component class. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class CustomWorkloadExecutor : VirtualClientComponent\n{\n    public CustomWorkloadExecutor(IServiceCollection dependencies, IDictionary<string, IConvertible> parameters = null)\n        : base(dependencies, parameters)\n    {\n    }\n}\n")),(0,o.kt)("p",null,"This constructor takes in the following parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"IServiceCollection"),(0,o.kt)("br",{parentName:"p"}),"\n","Provides all shared/common dependencies required by Virtual Client components (see section above). These core dependencies can be used to interoperate\nwith the Virtual Client core runtime platform as well as the system on which it is running.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"IDictionary<string, IConvertible>"),(0,o.kt)("br",{parentName:"p"}),"\n","Provides the parameters defined in the profile for the action, monitor or dependency handler step to the class instance."))),(0,o.kt)("h4",{id:"component-codemethod-flow"},"Component Code/Method Flow"),(0,o.kt)("p",null,"The following methods are executed in the order specified for each and every component in the Virtual Client platform. Of the methods listed, only the ExecuteAsync\nmethod is required to be implemented. The other methods are optional and may be overridden in the new component to meet the needs of the developer implementation."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"IsSupported"),(0,o.kt)("br",{parentName:"p"}),"\n","Method is executed to determin whether or not the component should be executed on the system. Reasons why a component might not be valid/supported\nfor a given system include:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The component or its dependencies cannot run on the current platform/architecture (e.g. win-arm64, linux-arm64)."),(0,o.kt)("li",{parentName:"ul"},"The component or its dependencies cannot run on the current distro of the operating system (e.g. Ubuntu, Redhat)."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ValidateParameters"),(0,o.kt)("br",{parentName:"p"}),"\n","Method allows the developer to validate the parameters that were passed to the component in the constructor.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"InitializeAsync"),(0,o.kt)("br",{parentName:"p"}),"\n","Method allows the developer to perform initial/preliminary validations and to set local member variables/properties that will be used when the\ncomponent ExecuteAsync() method is called. Some common things that are implemented in this method include:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Checks to ensure the component has the dependencies it needs to succeed (e.g. dependency packages, system settings)"),(0,o.kt)("li",{parentName:"ul"},"Setting member variables on the class instance that can be used later during the ExecuteAsync() call."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ExecuteAsync"),(0,o.kt)("br",{parentName:"p"}),"\n","Method is where the developer should perform the main body of work for the component. For example, this method may execute a workload binary\nor test on the system. Additionally, this is the step where measurements/metrics captured from running workload or script binaries are parsed\nand captured.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"CleanupAsync"),(0,o.kt)("br",{parentName:"p"}),"\n","Method allows the developer to perform any cleanup operations. For example, certain workload binaries leave log files as output on the file system.\nIt is a good idea to always cleanup any artifacts created during the operation of the component. This helps to ensure idempotency with components that\nrun in the Virtual Client runtime."))),(0,o.kt)("h2",{id:"trace-logging-and-telemetry"},"Trace Logging and Telemetry"),(0,o.kt)("p",null,"All logging in the Virtual Client is telemetry. Telemetry differs from traditional free-form logging because it is typically more highly structured. Even trace\nlogging in the Virtual Client is structured telemetry. When writing code in the Virtual Client, a few different extension methods are provided that should be used to ensure that\nlogging is routed correctly. There are 3 different categories of telemetry in the Virtual Client each with its own logging extension method(s)."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Trace Logs Telemetry"),(0,o.kt)("br",{parentName:"p"}),"\n","This category includes seneric application trace messages. These are used primarily for debugging purposes make it easy for the user to see exactly what the application is\ndoing. Trace messages are especially important for situations where operations are failing in the Virtual Client. In most cases, errors are automatically captured by the\nlogging mechanics of the Virtual Client. Having the error messages and callstack available is very helpful for determining root causes of issues."),(0,o.kt)("p",{parentName:"li"},'There are 2 different levels of importance for trace messages in the Virtual Client. A "trace message" will always be LogLevel.Trace. These messages are typically used for\nverbose output and will display in the console output ONLY when the "--debug" flag is used on the command line.'))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'this.Logging.LogTraceMessage($"AnyComponent.PerformOperation", telemetryContext);\n\n// A corresponding asynchronous method implementation exists as well.\nawait this.Logging.LogTraceMessageAsync($"AnyComponent.PerformOperation", telemetryContext)\n    .ConfigureAwait(false);\n')),(0,o.kt)("p",null,"  The second type of trace message is the application informational message. The messages are typically LogLevel.Information but may be any log level. This type of trace message\nis always output to console output and to other targets."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'this.Logging.LogMessage($"AnyComponent.PerformOperation", LogLevel.Information, telemetryContext);\nthis.Logging.LogMessage($"AnyComponent.SomeTypeOfError", LogLevel.Error, telemetryContext);\n\n// A corresponding asynchronous method implementation exists as well.\nawait this.Logging.LogMessageAsync($"AnyComponent.PerformOperation", LogLevel.Information, telemetryContext)\n    .ConfigureAwait(false);\n\n// Error information is easy to capture as well using this logging extension method.\ntry\n{\n     // Some kind of logic that could result in exceptions happening.\n}\ncatch (Exception exc)\n{\n    this.Logging.LogMessage("AnyComponent.SomeOperationError", LogLevel.Error, telemetryContext.AddError(exc));\n}\n')),(0,o.kt)("p",null,"  The developer will often see a particular LogMessage/LogMessageAsync extension method being used that wraps an entire block of\ncode. This extension provides additional functionality desirable when logging information including capturing the time (in milliseconds)\nthat the logic in the block of code took to execute and automatically handling + capturing error information."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'return this.Logging.LogMessageAsync($"AnyComponent.PerformOperation", telemetryContext, async () =>\n{\n    // A block of 1 or more lines of code inside of here to perform some set of operations.\n    // This logging extension provides some nice features around logging:\n    //\n    // 1) A "Start" event is written capturing a timestamp at the beginning of the logic block operations\n    //   (e.g. AnyComponent.PerformOperationStart).\n    //\n    // 2) A "Stop" event is written capturing a timestamp at the end of the logic block operations (e.g. AnyComponent.PerformOpertionStop). \n    //    This event will contain a propery \'durationMs\' in the telemetry message context/custom dimensions that defines the length of\n    //    time in milliseconds the logic took. This can be helpful when analyzing the performance of logic later on\n    //    without needing to perform date/time math.\n    //\n    // 3) Any exceptions/errors that are throw will be automatically captured and the error messages + callstack will be added to\n    //    an "Error" message (e.g. AnyComponent.PerformOpertionError).\n    //\n    // All of this functionality is wrapped up in the extension method which allows for consistency in telemetry event names and\n    // error handling while significantly reducing "noise" in the code related to telemetry logic.\n});\n')),(0,o.kt)("p",null,"  The Virtual Client framework additionally has a logging extension method for cases where the developer wants to treat exceptions/errors as\ntraditional free-form logging vs. structured logging."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"try\n{\n     // Some kind of logic that could result in exceptions happening.\n}\ncatch (Exception exc)\n{\n    this.Logging.LogErrorMessage(exc, telemetryContext);\n}\n\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Metrics/Measurements Telemetry"),(0,o.kt)("br",{parentName:"li"}),"One of the primary goals of the Virtual Client runtime is to capture and structure metrics/measurements from the output of workloads, tests\nand monitors. To ensure consistency in the structure of metrics/measurements, a logging extension method is provided for the purpose.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'private void CaptureMetrics(IProcessProxy process, DateTime startTime, DateTime endTime, EventContext telemetryContext)\n{\n    string workloadResults = process.StandardOutput.ToString();\n    ExampleWorkloadMetricsParser resultsParser = new ExampleWorkloadMetricsParser(workloadResults);\n    IList<Metric> workloadMetrics = resultsParser.Parse();\n\n    this.Logger.LogMetrics(\n        toolName: "ExampleWorkload",\n        scenarioName: "some_unique_scenario_for_the_workload",\n        scenarioStartTime: startTime,\n        scenarioEndTime: endTime,\n        metrics: workloadMetrics,\n        metricCategorization: null,\n        scenarioArguments: "ExampleWorkload.exe --any=command --line=arguments",\n        this.Tags,\n        telemetryContext);\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"System Events Telemetry"),(0,o.kt)("br",{parentName:"li"}),"The Virtual Client also has a logging extension designed for capturing important information or events from the system on which it is running. This extension\nallows the developer to capture this information and to ensure it is routed together for distinction in telemetry storage resources.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'// The only requirement for the dictionary values (e.g. the object instances) is that\n// it is JSON-serializable.\nIDictionary<string, object> eventLogEntries = this.GetEventLogEntries(eventId: 21);\nthis.Logger.LogSystemEvents("AnyMonitor.CaptureEventLogs", eventLogEntries, telemetryContext)\n')),(0,o.kt)("h2",{id:"telemetry-loggers"},"Telemetry Loggers"),(0,o.kt)("p",null,"The Virtual Client uses a set of different types of loggers each implementing the .NET ILogger interface:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Console Logger"),(0,o.kt)("br",{parentName:"p"}),"\n",'Used to write telemetry messages to the console standard output and error streams (e.g. on-screen logging). Verbose output on-screen is enabled in the\nVirtual Client by supplying the "--debug" flag on the command line.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"File Logger"),(0,o.kt)("br",{parentName:"p"}),"\n",'Used to write telemetry messages to log files. Virtual Client writes 3 different types of log files that can all be found in the application "logs" directory.\nThe 3 different log files include those that contain general trace logging and messages, those that include workload and system metrics information only and those that\ncontain system performance counter measurements and information.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Event Hub Logger"),(0,o.kt)("br",{parentName:"p"}),"\n",'Used to upload telemetry messages to an Azure Event Hubs namespace. In practice the Virtual Client uses 3 or 4 different Event Hubs within the namespace to section\noff the data by its category (e.g. traces vs. metrics). Azure provides out-of-box support for a number of different "big data" storage resources that can ingest the telemetry\nfrom the Event Hubs into storage. For example the VC Team connects Azure Data Explorer/Kusto clusters to the Event Hub so that the telemetry emitted to the Event Hub is being\nautomatically ingested into the cluster databases.'))),(0,o.kt)("h2",{id:"code-examples"},"Code Examples"),(0,o.kt)("p",null,'Sometimes the very best documentation for developers to learn is hands-on coding. The VC Team has included a set of code examples that illustrate some of the\nimplementation concepts. Good news! If you are at this point, your manager can no longer give you a hard time talking about "implementation details".\nThe devil is in them from this point forward, so enjoy!! :) Each of the examples below can be ran right at the developer desktop for breakpoint/debugging\neuphoria. We typically use the Visual Studio IDE due to its robust support for developer "inner-loop" needs.'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Example Implementations"),(0,o.kt)("br",{parentName:"p"}),"\n","The following examples illustrate some of the basic implementation concepts for Virtual Client workload/test executors and monitors. These examples are\nused in an example workload profile. The examples can be run at the desktop within Visual Studio for live debugging."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Main/profiles/EXAMPLE-WORKLOAD.json"},"Example Workload + Monitoring Profile"),(0,o.kt)("br",{parentName:"p"}),"\n","This profile references the example workload executor below as well as the example monitor. This profile also has a dependency installer/handler in it\nto download a workload package from a blob store. This profile can be run at the desktop to see how things work. Note that you will need a SAS URI to the\nVC Team storage account where the workload packages exist. Virtual Client will be downloading dependency packages from here. Contact the VC Team to get\na SAS URI for your needs."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"To Debug: In Visual Studio:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Set the 'VirtualClient.Main' project as the 'Startup project'."),(0,o.kt)("li",{parentName:"ul"},"Right-click on this project and select 'Properties' from the menu."),(0,o.kt)("li",{parentName:"ul"},"In the 'Debug' section, put the following in for the 'Application arguments':",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"--profile=EXAMPLE-WORKLOAD.json --timeout=1440 --packages={{YourBlobStoreSASUri}}"))))))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions/Examples/ExampleWorkloadExecutor.cs"},"Example Workload/Test Executor"),(0,o.kt)("br",{parentName:"p"}),"\n","Provides a coded example for how to write a basic workload executor.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Monitors/ExampleProfilingMonitor.cs"},"Workload/Test Executor and Background Profiling Monitor"),(0,o.kt)("br",{parentName:"p"}),"\n","Provides a coded example of how to write a monitor that can be used for background profiling operations (both Interval-based as well as On-Demand)."))))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions/Examples/ClientServer"},"Example Client/Server Executor"),(0,o.kt)("br",{parentName:"p"}),"\n","Provides a coded example for how to write advanced, client/server workload executors.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Examples of Unit Tests"),(0,o.kt)("br",{parentName:"p"}),"\n","The following examples illustrate some of the unit testing concepts in the Virtual Client codebase."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions.UnitTests/Example2WorkloadExecutor.cs"},"Example Action/Executor"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Example Tests using MockFixture"),(0,o.kt)("br",{parentName:"p"}),"\n","Provides examples of basic unit testing concepts along with the use of the MockFixture helper class."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions.UnitTests/Example2WorkloadExecutorTests_MockFixture.cs"},"Example Tests")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Example Tests using DependencyFixture"),(0,o.kt)("br",{parentName:"p"}),"\n","Provides examples of basic unit testing concepts along with the use of the DependencyFixture helper class. This class differs from the MockFixture\nin that it uses in-memory implementations of the Virtual Client platform core dependencies. It is typically used for functional testing in Virtual Client\nprojects."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/microsoft/VirtualClient/blob/main/src/VirtualClient/VirtualClient.Actions.UnitTests/Example2WorkloadExecutorTests_DependencyFixture.cs"},"Example Tests"))))))),(0,o.kt)("h2",{id:"debugging-virtual-client-code"},"Debugging Virtual Client Code"),(0,o.kt)("p",null,"The sections below document some of the ways in which the developer can debug components in the Virtual Client. The Visual Studio IDE is used for these examples because of its\nrobust support for developer inner-loop processes including support for debugging."),(0,o.kt)("h4",{id:"debug-in-visual-studio-using-unitfunctional-tests"},"Debug in Visual Studio Using Unit/Functional Tests"),(0,o.kt)("p",null,"There is no faster way to get a debugger attached to your code than via an Nunit test. The Visual Studio 'Test Explorer' makes it very\neasy to put a break point in the code of a test method, to right-click in the test and then to select 'Debug Test(s)' from the context\nmenu. From that point Visual Studio will build your source code and will execute the test with a debugger attached. The VC Team often\nhas 3 different types of test projects in source (i.e. unit, functional, integration) that are used for testing the code with various\ngoals and these are all just as easy to use for debugging purposes."),(0,o.kt)("p",null,"Once you have written a unit/functional test in Visual Studio:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Place a breakpoint at the beginning of the test method."),(0,o.kt)("li",{parentName:"ul"},"Right-click in the test."),(0,o.kt)("li",{parentName:"ul"},'Select "Debug Test(s)" from the context menu.')),(0,o.kt)("p",null,"Visual Studio will build the source code, attach a debugger to the test execution runner and will run the test code. The debugger will hit your breakpoint in the test. From that\npoint forward, you can step through your code as normal (e.g. F5, F10, F11 debug stepping)."),(0,o.kt)("h4",{id:"debug-in-visual-studio-by-running-a-custom-profile"},"Debug in Visual Studio by Running a Custom Profile"),(0,o.kt)("p",null,"The developer may sometimes want to run the full Virtual Client runtime executable to debug his/her code. This is often the case when the developer wants to test the code live and\nwithout any mocks. To do this, it is easiest to create a custom profile in a directory on the file system that contains actions, monitors, dependencies definitions related to the class\nthe developer wants to debug. If the profile is for debugging purposes only, it is best to create it in a directory outside of source control and to place ONLY the components\nin the profile required for correct operations. For example, the developer may be creating a new action/workload executor and wants to test it. This action/workload executor may\nrequire a dependency package exist or be downloaded at runtime. The developer can either place the dependency package in the build output directory for the Virtual Client or can\nput an appropriate DependencyPackageInstallation component in the profile so that it can be downloaded (assuming the dependency package exists in the package store). The following\nexamples illustrate how to do this."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Custom Profile Option #1"),(0,o.kt)("br",{parentName:"p"}),"\n","In this example, a custom profile will be used to debug an action/executor on which the developer is working (e.g. ExampleWorkloadExecutor below). This action/executor requires\na specific dependency package containing workload binaries to be downloaded. A custom profile will be used to incorporate the action/executor and the workload dependency package."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-json"},'# A custom profile is created and placed on the file system somewhere (typically somewhere outside of the source directory). In this profile, the\n# custom action/executor component is added to the actions and the dependency package installation component is added to the dependencies.\n{\n  "Description": "Debug Example Workload Executor",\n  "Actions": [\n      {\n          "Type": "ExampleWorkloadExecutor",\n          "Parameters": {\n              "Scenario": "Scenario1",\n              "CommandLine": "Workload duration=00:01:00",\n              "ExampleParameter1": "AnyValue1",\n              "ExampleParameter2": 4567,\n              "PackageName": "exampleworkload",\n              "Tags": "Test,VC"\n          }\n      }\n  ],\n  "Dependencies": [\n      {\n          "Type": "DependencyPackageInstallation",\n          "Parameters": {\n              "Scenario": "InstallExampleWorkloadPackage",\n              "BlobContainer": "packages",\n              "BlobName": "exampleworkload.1.0.0.zip",\n              "PackageName": "exampleworkload",\n              "Extract": true\n          }\n      }\n  ]\n}\n')))),(0,o.kt)("p",null,"  Once the profile is created, setup Visual Studio for debugging"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Set the solution configuration to ",(0,o.kt)("strong",{parentName:"li"},"Debug")," at the top of the Visual Studio IDE window."),(0,o.kt)("li",{parentName:"ol"},"Set the ",(0,o.kt)("strong",{parentName:"li"},"VirtualClient.Main")," project as the startup project. To do so, right-click on the project in the Solution Explorer and select\n",(0,o.kt)("strong",{parentName:"li"},"Set as Startup Project")," from the context menu."),(0,o.kt)("li",{parentName:"ol"},"Right-click on the VirtualClient.Main project and open the ",(0,o.kt)("strong",{parentName:"li"},"Debug")," options. Set the following information.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Application arguments =",(0,o.kt)("inlineCode",{parentName:"li"},'--profile={PathToCustomProfile} --profile=MONITORS-NONE.json --packages="{PackageStoreConnectionString|SASUri}"'),".",(0,o.kt)("br",{parentName:"li"}),"(e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},'--profile=S:\\one\\debugging\\DEBUG-EXAMPLE-WORKLOAD.json --profile=MONITORS-NONE.json --packages="https://virtualclient..."'),")"))),(0,o.kt)("li",{parentName:"ol"},"Place a breakpoint in the code where you like (e.g. in the InitializeAsync or ExecuteAsync methods of your component)."),(0,o.kt)("li",{parentName:"ol"},"Click the play/continue button at the top-center of the Visual Studio IDE window (or press the F5 key).")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Custom Profile Option #2"),(0,o.kt)("br",{parentName:"li"}),'This option is the same as option #1 above except that the developer will copy the workload dependency package to the appropriate directory in the\nVirtual Client build output directory ahead of time. Once the package is in this directory, the Virtual Client does not need to download it and thus\nthe custom profile can be simplified by removing the "Dependencies" section as illustrated below.')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'# A custom profile is created and placed on the file system somewhere (typically somewhere outside of the source directory). In this profile, the\n# custom action/executor component is added to the actions.\n{\n  "Description": "Debug Example Workload Executor",\n  "Actions": [\n      {\n          "Type": "ExampleWorkloadExecutor",\n          "Parameters": {\n              "Scenario": "Scenario1",\n              "CommandLine": "Workload duration=00:01:00",\n              "ExampleParameter1": "AnyValue1",\n              "ExampleParameter2": 4567,\n              "PackageName": "exampleworkload",\n              "Tags": "Test,VC"\n          }\n      }\n  ]\n}\n')),(0,o.kt)("p",null,"  The workload dependencies package must be copied into the ",(0,o.kt)("strong",{parentName:"p"},"{","repo_directory","}","/out/bin/Debug/x64/VirtualClient.Main/packages"),"\ndirectory before beginning to debug."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"e.g.\nS:\\one\\virtualclient\\out\\bin\\Debug\\VirtualClient.Main\\packages\\exampleworkload.1.0.0.zip\n")),(0,o.kt)("p",null,"  Once the profile is created, setup Visual Studio for debugging"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Set the solution configuration to ",(0,o.kt)("strong",{parentName:"li"},"Debug")," at the top of the Visual Studio IDE window."),(0,o.kt)("li",{parentName:"ol"},"Set the ",(0,o.kt)("strong",{parentName:"li"},"VirtualClient.Main")," project as the startup project. To do so, right-click on the project in the Solution Explorer and select\n",(0,o.kt)("strong",{parentName:"li"},"Set as Startup Project")," from the context menu."),(0,o.kt)("li",{parentName:"ol"},"Right-click on the VirtualClient.Main project and open the ",(0,o.kt)("strong",{parentName:"li"},"Debug")," options. Set the following information.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Application arguments = ",(0,o.kt)("inlineCode",{parentName:"li"},"--profile={PathToCustomProfile} --profile=MONITORS-NONE.json"),".",(0,o.kt)("br",{parentName:"li"}),"(e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"--profile=S:\\one\\debugging\\DEBUG-EXAMPLE-WORKLOAD.json --profile=MONITORS-NONE.json"),")"))),(0,o.kt)("li",{parentName:"ol"},"Place a breakpoint in the code where you like (e.g. in the InitializeAsync or ExecuteAsync methods of your component)."),(0,o.kt)("li",{parentName:"ol"},"Click the play/continue button at the top-center of the Visual Studio IDE window (or press the F5 key).")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Custom Profile Option #3"),(0,o.kt)("br",{parentName:"p"}),"\n","This option is the same as option #2 above except that we will set an environment variable to the path/directory location of the workload dependency\npackage on the system."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-json"},'# A custom profile is created and placed on the file system somewhere (typically somewhere outside of the source directory). In this profile, the\n# custom action/executor component is added to the actions.\n{\n  "Description": "Debug Example Workload Executor",\n  "Actions": [\n      {\n          "Type": "ExampleWorkloadExecutor",\n          "Parameters": {\n              "Scenario": "Scenario1",\n              "CommandLine": "Workload duration=00:01:00",\n              "ExampleParameter1": "AnyValue1",\n              "ExampleParameter2": 4567,\n              "PackageName": "exampleworkload",\n              "Tags": "Test,VC"\n          }\n      }\n  ]\n}\n')),(0,o.kt)("p",{parentName:"li"},"The workload dependencies package exists in a directory on the system already. We set an environment variable ",(0,o.kt)("strong",{parentName:"p"},"VCDependenciesPath")," to this path/directory location\nbefore beginning to debug."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"},"e.g.\n\n# Workload dependency package exists in a folder on the file system. We will set the 'VCDependenciesPath' environment variable to this\n# location.\nS:\\one\\debugging\\packages\\exampleworkload.1.0.0.zip\n")),(0,o.kt)("p",{parentName:"li"},"Once the profile is created, setup Visual Studio for debugging"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"Set the solution configuration to ",(0,o.kt)("strong",{parentName:"li"},"Debug")," at the top of the Visual Studio IDE window."),(0,o.kt)("li",{parentName:"ol"},"Set the ",(0,o.kt)("strong",{parentName:"li"},"VirtualClient.Main")," project as the startup project. To do so, right-click on the project in the Solution Explorer and select\n",(0,o.kt)("strong",{parentName:"li"},"Set as Startup Project")," from the context menu."),(0,o.kt)("li",{parentName:"ol"},"Right-click on the VirtualClient.Main project and open the ",(0,o.kt)("strong",{parentName:"li"},"Debug")," options. Set the following information.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Application arguments = ",(0,o.kt)("inlineCode",{parentName:"li"},"--profile={PathToCustomProfile}"),".",(0,o.kt)("br",{parentName:"li"}),"(e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"--profile=S:\\one\\debugging\\DEBUG-EXAMPLE-WORKLOAD.json --profile=MONITORS-NONE.json"),")"),(0,o.kt)("li",{parentName:"ul"},"Environment variables = Add the ",(0,o.kt)("inlineCode",{parentName:"li"},"VCDependenciesPath")," variable and the path to your package directory.",(0,o.kt)("br",{parentName:"li"}),"(e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"VCDependenciesPath = S:\\one\\debugging\\packages"),")"))),(0,o.kt)("li",{parentName:"ol"},"Place a breakpoint in the code where you like (e.g. in the InitializeAsync or ExecuteAsync methods of your component)."),(0,o.kt)("li",{parentName:"ol"},"Click the play/continue button at the top-center of the Visual Studio IDE window (or press the F5 key).")))))}c.isMDXComponent=!0}}]);